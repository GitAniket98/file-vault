{
  "language": "Solidity",
  "sources": {
    "contracts/fileVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title FileVault - On-chain access control for encrypted off-chain storage\n/// @notice Stores encrypted file references (hash + CID) and manages access with security improvements\ncontract FileVault {\n    struct File {\n        address uploader; // Who uploaded the file\n        string cid; // IPFS CID of the encrypted file\n        mapping(address => bool) authorized; // Access control\n        bool exists; // Flag to check if file exists\n    }\n\n    // Constants for security limits\n    uint256 public constant MAX_ALLOWED_USERS = 100;\n\n    // Mapping: fileHash (SHA-256 of encrypted file) => File struct\n    mapping(bytes32 => File) private files;\n\n    /// @dev Events for frontend/backends to track changes\n    event FileUploaded(bytes32 indexed fileHash, string cid, address indexed uploader, address[] allowedUsers);\n    event FileUpdated(bytes32 indexed fileHash, string newCid, address indexed uploader);\n    event FileDeleted(bytes32 indexed fileHash, address indexed uploader);\n    event AccessGranted(bytes32 indexed fileHash, address indexed user);\n    event AccessRevoked(bytes32 indexed fileHash, address indexed user);\n    event OwnershipTransferred(bytes32 indexed fileHash, address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Upload a new file reference (CID + hash) and set initial access list\n    /// @param fileHash SHA-256 hash of the encrypted file\n    /// @param cid IPFS CID of the encrypted file\n    /// @param allowedUsers List of addresses initially granted access\n    function storeFileHash(bytes32 fileHash, string calldata cid, address[] calldata allowedUsers) external {\n        require(!files[fileHash].exists, \"File already exists\");\n        require(bytes(cid).length > 0, \"CID cannot be empty\");\n        require(allowedUsers.length <= MAX_ALLOWED_USERS, \"Too many users\");\n\n        File storage f = files[fileHash];\n        f.uploader = msg.sender;\n        f.cid = cid;\n        f.exists = true;\n\n        // Automatically grant access to uploader\n        f.authorized[msg.sender] = true;\n\n        // Grant access to allowed users (with duplicate and zero address checks)\n        for (uint256 i = 0; i < allowedUsers.length; i++) {\n            address user = allowedUsers[i];\n            require(user != address(0), \"Invalid address in allowedUsers\");\n\n            // Only set if not already authorized (prevents wasted gas on duplicates)\n            if (!f.authorized[user]) {\n                f.authorized[user] = true;\n            }\n        }\n\n        emit FileUploaded(fileHash, cid, msg.sender, allowedUsers);\n    }\n\n    /// @notice Update the CID of an existing file (only uploader can update)\n    /// @param fileHash SHA-256 hash of the file\n    /// @param newCid New IPFS CID\n    function updateCid(bytes32 fileHash, string calldata newCid) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n        require(bytes(newCid).length > 0, \"CID cannot be empty\");\n\n        files[fileHash].cid = newCid;\n        emit FileUpdated(fileHash, newCid, msg.sender);\n    }\n\n    /// @notice Delete a file reference and clear all access (only uploader can delete)\n    /// @param fileHash SHA-256 hash of the file\n    function deleteFile(bytes32 fileHash) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n\n        // Note: Due to Solidity limitations, we cannot iterate and delete all authorized users\n        // The mapping will remain in storage but the file is marked as deleted\n        files[fileHash].exists = false;\n        files[fileHash].uploader = address(0);\n        files[fileHash].cid = \"\";\n\n        emit FileDeleted(fileHash, msg.sender);\n    }\n\n    /// @notice Transfer ownership of a file to a new address (only uploader can transfer)\n    /// @param fileHash SHA-256 hash of the file\n    /// @param newOwner Address of the new owner\n    function transferOwnership(bytes32 fileHash, address newOwner) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n        require(newOwner != address(0), \"Invalid new owner address\");\n        require(newOwner != msg.sender, \"Already the owner\");\n\n        address previousOwner = files[fileHash].uploader;\n        files[fileHash].uploader = newOwner;\n\n        // Automatically grant access to new owner\n        files[fileHash].authorized[newOwner] = true;\n\n        emit OwnershipTransferred(fileHash, previousOwner, newOwner);\n    }\n\n    /// @notice Grant access to a user (only uploader can grant)\n    /// @param fileHash SHA-256 hash of the file\n    /// @param user Address to grant access to\n    function grantAccess(bytes32 fileHash, address user) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n        require(user != address(0), \"Invalid user address\");\n\n        files[fileHash].authorized[user] = true;\n        emit AccessGranted(fileHash, user);\n    }\n\n    /// @notice Grant access to multiple users (only uploader can grant)\n    /// @param fileHash SHA-256 hash of the file\n    /// @param users Array of addresses to grant access to\n    function grantAccessBatch(bytes32 fileHash, address[] calldata users) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n        require(users.length <= MAX_ALLOWED_USERS, \"Too many users\");\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            require(user != address(0), \"Invalid user address\");\n\n            if (!files[fileHash].authorized[user]) {\n                files[fileHash].authorized[user] = true;\n                emit AccessGranted(fileHash, user);\n            }\n        }\n    }\n\n    /// @notice Revoke access from a user (only uploader can revoke)\n    /// @param fileHash SHA-256 hash of the file\n    /// @param user Address to revoke access from\n    function revokeAccess(bytes32 fileHash, address user) external {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].uploader == msg.sender, \"Not uploader\");\n        require(user != address(0), \"Invalid user address\");\n\n        files[fileHash].authorized[user] = false;\n        emit AccessRevoked(fileHash, user);\n    }\n\n    /// @notice Check if a user is authorized to access a file\n    /// @param fileHash SHA-256 hash of the file\n    /// @param user Address to check\n    /// @return bool True if authorized, false otherwise\n    function isAuthorized(bytes32 fileHash, address user) external view returns (bool) {\n        require(files[fileHash].exists, \"File does not exist\");\n        return files[fileHash].authorized[user];\n    }\n\n    /// @notice Check if caller is authorized to access a file\n    /// @param fileHash SHA-256 hash of the file\n    /// @return bool True if authorized, false otherwise\n    function canAccess(bytes32 fileHash) external view returns (bool) {\n        require(files[fileHash].exists, \"File does not exist\");\n        return files[fileHash].authorized[msg.sender];\n    }\n\n    /// @notice Get the uploader of a file\n    /// @param fileHash SHA-256 hash of the file\n    /// @return address Address of the uploader\n    function getUploader(bytes32 fileHash) external view returns (address) {\n        require(files[fileHash].exists, \"File does not exist\");\n        return files[fileHash].uploader;\n    }\n\n    /// @notice Get the CID of a file (only authorized users can access)\n    /// @param fileHash SHA-256 hash of the file\n    /// @return string IPFS CID\n    function getCid(bytes32 fileHash) external view returns (string memory) {\n        require(files[fileHash].exists, \"File does not exist\");\n        require(files[fileHash].authorized[msg.sender], \"Not authorized to access this file\");\n        return files[fileHash].cid;\n    }\n\n    /// @notice Check if a file exists\n    /// @param fileHash SHA-256 hash of the file\n    /// @return bool True if file exists, false otherwise\n    function fileExists(bytes32 fileHash) external view returns (bool) {\n        return files[fileHash].exists;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}